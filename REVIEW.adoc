= Code Review Compendium

== Code smells

The code contains quite a few "Code Smells". See: https://en.wikipedia.org/wiki/Code_smell
That should not be considered lightly. There are serious deficiencies noticeable at first glance.

== Code duplication

There is *massive* duplication of code. Not just apparent utility functions like `dirExists` - with separate definitions in 4 files - but also the whole HTML generations seems to be duplicated.

There is the same (!) code for HTML generation in `asciidoc.ts`, `html.ts` and `pdf.ts`. That MUST be refactored in a separate HTML generation backend (utility component).

== Lack of design

The code is nicely structured according to the initial design as defined by the interfaces in `types.ts`. From that moment on there is *no apparent thought on how the code is supposed to be structured*. The different implementations like `AsciiDocFileTextOut` are just large buckets of private methods without any apparent thought on code design or structure.

== Sloppy naming, a smell of sloppy coding

There are a number of instances where not a lot of attention has been spend to the quality of the code as reflected by, for example, the sloppy naming of:

```typescript
export interface Code {
   kind: 'code';
   languaje?: string;
   content: string;
}
```

Coding standard in the _ADCenter_ is "English" for code, naming & comments, unless specified otherwise.

== Invalid usage and inconsistent usage of patterns

There are *sync calls* used which is the biggest anti-pattern that can be used in node.js. It _may_ be permissible but the reasons for the usage should have been documented. Furthermore, there is little coherence in patterns used. There is no consistency in usage of _Promises_, like in `confluenceservice.ts` and the usage of _async/await_.

== Incomplete and incorrect tests

First of all, the test fail when getting MASTER from Gitlab. That is an absolute no-no. All Tests MUST succeed before checking in. That is not an optional thing. In a real development environment there would be a Jenkins based Continuous Integration based pipeline which would always FAIL in case of Compendium.

For the remainder, the tests are insufficient and plainly badly done. To sum up:

- There is a mix-up of unit tests and integration tests. Integration test with a real Confluence (look at confluence.test.ts) MUST NOT be executed in the same context as the unit tests. They will always fail on the machine of someone who does not have Confluence installed. 
- The unit tests are not really _unit_ tests. See: https://en.wikipedia.org/wiki/Unit_testing . There is no clear test strategy nor plan visible on how to encompass a "unit" with tests to validate its functionality
- It is *very* apparent by the test coverage and structure of the tests that little if no TDD has been applied.

== Sloppy housekeeping

Housekeeping (https://en.wikipedia.org/wiki/Housekeeping) is used metaphorically in Computer Science and Programming for a variety of different purposes. One is the describe the way how at a project and file-level things are organized. That should improve in Compendium as just at first glance there are to be found:

- Two README files (one AsciiDoc and one Markdown)
- files in the root who do not belong there. Apparent files from the development process included in Git 
- remnants of MyThaiStar, for example in ´.gitignore´
- testdata/output is incorporated in Git (temporary and/or output files should NEVER be included in Git)
- Still local references incorporated in files. See: `config.json` with `"C:/Users/sbadenes/Desktop/devonm/devon-methodology"`

== Case: config.ts - method getIndex

Method `getIndex` on the `ConfigFile` class in file `config.ts` is a good example of rather flaky programming:

- the interface `DocConfig` (implemented in `ConfigFile`) has the single method `getIndex` which should return a promise. But the actual implementation does not use _async_ functionality. It is actually using the anti-pattern of getting the synchronous `fs.readFileSync`. 

- There is a substantial amount of needless pseudo-defensive programming. Checks of the existence of particular properties ("Confluence"; "asciidoc") etc. which is all useless and besides created a tight coupling between distinct components within the application. Any failure would have been generated anyway (for example: a "conPLUENCE" property would have failed as there is no "conPLUENCE TextInSource"). In other words: "it is better to ask forgiveness rather than permission".

== Case: asciidoc.ts - method generate

Method `generate` on the `AsciiDocFileTextOut` class in file `asciidoc.ts` does harbour a series of problems as well:

- Principally the way a temporary directory file is created and treated is non-standard. There is an API available for that. 

- a critical error is the string concatenation used for building up am output string (i.e. s3 = s2 + s1). The correct way is to use a String Builder or equivalent. In Javascript a similar way would be to use an array of text chunks, add the new output to the tail of the array (method `push`) and than to join the elements into one item (method `join`).

- A component is loaded using `require` syntax

```typescript
const ncp = require('ncp').ncp;
```
however, the `import` syntax in TypeScript should be used.

- the continuous usage of the word "parse(d)" indicates that there is no real understanding of what parsing actually _means_ in Computer Science. From text to an AST (Abstract Syntax Tree) or Intermediate Representation (EM) is done by a Parser. However, in `AsciiDocFileTextOut` an EM is taken as input and real source code, textual information, is being generated. So: `EM ➞ Text` rather than `Text ➞ EM`, therefore the inverse of parsing. That process is called "emit". The methods should therefore be called `emit*` rather than `*Parsed`, so `emitTextElement` rather than `textElementParsed`.


